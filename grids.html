<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strict Shape Packer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .grid-container { 
            display: grid; 
            grid-auto-rows: 25px; /* Adjust for vertical density */
            gap: 8px;
        }
    </style>
</head>
<body class="bg-slate-950 text-white p-6">

    <div class="max-w-6xl mx-auto">
        <header class="bg-slate-900 p-6 rounded-2xl border border-slate-800 shadow-xl mb-8">
            <div class="flex flex-wrap gap-6 items-end">
                <div class="flex flex-col">
                    <label class="text-[10px] uppercase tracking-widest text-slate-500 mb-1">Grid Width</label>
                    <input id="widthInput" type="number" value="10" class="bg-slate-800 border border-slate-700 rounded-lg px-3 py-2 w-20 font-bold outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                
                <div class="flex flex-col flex-1 min-w-[300px]">
                    <label class="text-[10px] uppercase tracking-widest text-slate-500 mb-1">Allowed Shapes (WxH)</label>
                    <input id="sizeInput" type="text" value="2x3 2x2 4x5 6x3 3x3" 
                        class="bg-slate-800 border border-slate-700 rounded-lg px-3 py-2 font-mono text-sm focus:ring-2 focus:ring-blue-500 outline-none w-full">
                </div>

                <button id="refreshBtn" class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-8 rounded-lg transition-all active:scale-95">
                    Pack Grid
                </button>
            </div>
        </header>

        <div id="gridElement" class="grid-container"></div>
        
        <div id="errorLog" class="mt-4 text-rose-400 text-sm font-mono"></div>
    </div>

    <script>
        const gridElement = document.getElementById('gridElement');
        const widthInput = document.getElementById('widthInput');
        const sizeInput = document.getElementById('sizeInput');
        const refreshBtn = document.getElementById('refreshBtn');
        const errorLog = document.getElementById('errorLog');

        const COLORS = ['bg-blue-600', 'bg-indigo-600', 'bg-violet-600', 'bg-fuchsia-600', 'bg-emerald-600', 'bg-cyan-600', 'bg-sky-600'];

        function pack() {
            const gridWidth = parseInt(widthInput.value) || 10;
            const shapes = sizeInput.value.split(/\s+/).map(s => s.split('x').map(Number));
            
            gridElement.innerHTML = '';
            errorLog.innerHTML = '';
            gridElement.style.gridTemplateColumns = `repeat(${gridWidth}, minmax(0, 1fr))`;

            // State: 2D array tracking occupied cells [row][col]
            const occupied = []; 
            const maxRows = 100;

            function isAreaEmpty(r, c, w, h) {
                if (c + w > gridWidth) return false; // Overflows width
                for (let i = r; i < r + h; i++) {
                    for (let j = c; j < c + w; j++) {
                        if (!occupied[i]) occupied[i] = [];
                        if (occupied[i][j]) return false;
                    }
                }
                return true;
            }

            function markArea(r, c, w, h) {
                for (let i = r; i < r + h; i++) {
                    for (let j = c; j < c + w; j++) {
                        if (!occupied[i]) occupied[i] = [];
                        occupied[i][j] = true;
                    }
                }
            }

            // Start packing
            let blocksPlaced = 0;
            const targetBlocks = 40;

            for (let r = 0; r < maxRows && blocksPlaced < targetBlocks; r++) {
                for (let c = 0; c < gridWidth; c++) {
                    if (!occupied[r]) occupied[r] = [];
                    if (occupied[r][c]) continue; // Skip if cell is full

                    // Find a shape that fits here
                    let fitted = false;
                    // Shuffle shapes to give it a random feel
                    const shuffledShapes = [...shapes].sort(() => Math.random() - 0.5);

                    for (let [sw, sh] of shuffledShapes) {
                        if (isAreaEmpty(r, c, sw, sh)) {
                            markArea(r, c, sw, sh);
                            addBlockToDOM(r, c, sw, sh);
                            fitted = true;
                            blocksPlaced++;
                            break;
                        }
                    }

                    if (!fitted) {
                        // If NO shapes fit, we have a problem. 
                        // To keep it gapless, we must insert a 1x1 "filler" or report error.
                        errorLog.innerHTML += `Warning: No shape fits at [Col: ${c}, Row: ${r}]. Consider adding 1x1 to shapes.<br>`;
                        // Fill with 1x1 to prevent infinite loop/messy layout
                        markArea(r, c, 1, 1);
                        addBlockToDOM(r, c, 1, 1, true);
                    }
                }
            }
        }

        function addBlockToDOM(r, c, w, h, isFiller = false) {
            const div = document.createElement('div');
            const color = isFiller ? 'bg-slate-800 opacity-30' : COLORS[Math.floor(Math.random() * COLORS.length)];
            
            // Grid positions are 1-indexed in CSS
            div.style.gridColumn = `${c + 1} / span ${w}`;
            div.style.gridRow = `${r + 1} / span ${h}`;
            
            div.className = `${color} rounded-lg border border-white/10 flex flex-col items-center justify-center transition-all hover:scale-[1.02]`;
            div.innerHTML = `<span class="text-[10px] font-bold">${isFiller ? 'FILLER' : w+'x'+h}</span>`;
            
            gridElement.appendChild(div);
        }

        refreshBtn.addEventListener('click', pack);
        pack();
    </script>
</body>
</html>
